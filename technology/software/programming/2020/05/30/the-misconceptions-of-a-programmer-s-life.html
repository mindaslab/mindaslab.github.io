<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The Misconceptions of a Programmer‚Äôs Life | Karthikeyan A K‚Äôs blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="The Misconceptions of a Programmer‚Äôs Life" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I see frequent posts from beginning programmers wondering what programming is like, and I think it‚Äôs useful to address those issues. You program 8 hours a day at work This is probably the least true of all the things. Most programming jobs are maintenance jobs. The programs have all mostly been written years ago, and you are doing support, minor enhancements, bug fixes. Even if you get to do more than that, you are still not likely coding a large part of your day. It‚Äôs about meetings to decide what to do. Also, from my experience, unless you have some reason to dig deep into code (esp. if the code base is large), most people don‚Äôt bother. Our codebase is old and rickety. There aren‚Äôt comments. The business process isn‚Äôt exactly documented. I don‚Äôt want to wade through 2000 lines of Java code (per Java file) and try to understand the business behind it. Unless you‚Äôre working in a brand new project that needs a lot of code written (which I‚Äôve been in), you are probably not doing a lot of programming. A program is about programming I work at a university. Students, esp. computer science students, complain about our old system that runs a ‚Äúbatch style‚Äù programming system. That is, the system shuts down overnight, does a bunch of data processing, and opens again in the morning. They wonder why the system can‚Äôt be Facebook or Google or YouTube, and be up 24 hours a day. First, I think many such people would be surprised how many people (or really, how few people) are supporting these systems. You‚Äôd think there‚Äôs a team of 20 developers doing the best they can to keep this stuff running, and it‚Äôs like a well-oiled machine, but sometimes it‚Äôs less than half a dozen people, and we barely know the software‚Äôs purpose, but can do minor fixes and keep stuff running. Most software out there isn‚Äôt, as they say, rocket science. Sure, a few exceptions (say, SpaceX software). Most of the software encodes business practices, and most business practices are a weird arcane set of rules that have no basis in math or science, but is just how some company works. You write that in code, no matter how illogical it is. And often, the code, and a few old timers‚Äô memories are what holds the project together. Comments? Hah! A written business process? Hah! Programmers had one purpose: get the program to work. They didn‚Äôt think about who would maintain the code after they retired. The only saving grace was their background wasn‚Äôt so sophisticated as to create true spaghetti code (let‚Äôs use regular expressions and finite state machines and design patterns up the wazoo!). It‚Äôs often not the coding language (like Cobol) that prevents modernization (although it‚Äôs partly that), it‚Äôs that the business process was never formalized, and there are 100,000 lines of code no one wants to read (and only represents an approximation of what the people who wanted the code wanted‚Äîand they‚Äôre retired too!). I often point out the scene in the third Matrix movie where the councilman is talking to Neo about how these machines support their underground city, yet no one quite knows who built it or how it works. That‚Äôs a lot of software out there. Writing from scratch is not such a common experience (at least, from my perspective), and even when you do, it‚Äôs not always as organized as it could be. We may call it software engineering, but most engineering involves others looking at your work, and having input into fix it. Code reviews aren‚Äôt the same thing as people inspecting a building and seeing it every day. We often don‚Äôt rewrite things because the rewrite would be huge, would require a bunch of new developers, and doesn‚Äôt even have the support of the people we‚Äôre writing it for. As a programmer, since I wrote the code, my opinion is the most important OK, so you may know programming, but do you know the business you‚Äôre working in? Many a programmer or startup guy thinks ‚ÄúYou guys do something dumb, and I‚Äôm smart, so I can easily create a system that‚Äôs 10 times better than the crap you use. And you know what? I‚Äôm not even going to consult you about how the system should work. I‚Äôll make up my own. You are such idiots!‚Äù. Well, that may be, but they‚Äôre used to the system they are used to, and they‚Äôve thought about their own (arcane) business process for a long time, and if you build something that is completely different from what they are used to, they won‚Äôt say ‚Äúoh, we lack the intellect to understand your truly great software‚Äù, they‚Äôll just not use your software. If your user base is a bit older, and possibly, even if they aren‚Äôt, they will be used to doing things in a certain way. Maybe you can convince them that way isn‚Äôt smart, but if they questioned your lack of comments, your lack of coding structure, how what you wrote seems like gibberish, you might get defensive as well. The point is that you‚Äôre often writing software or maintaining software by those who use the software every day. As a programmer, you might even have the luxury to walk away after you write a code, never having used the code as your users use them, and they may ultimately hire someone new who maybe pays attention to what they actually want, even if you think it makes no sense. The program matters Many of you are learning to program. You think companies are willing to throw out a million line codebase because it‚Äôs written in an obsolete language. Who‚Äôs going to write it? You? (You, Mr. Wineburg?) A million lines of code is something that could take a lifetime to rewrite. Do you plan to read the code to understand what it does? Could you even do that? In any case, sometimes people think the program is king (or queen, or some elected position). It‚Äôs not. It‚Äôs the data. Say you‚Äôve run this legacy program for more than a decade. It fills up tables and table of data. You, being a person who hates legacy code, wants new DB tables, and new ways of storing information. Here‚Äôs the problem. What do you do with all that old data? Oh, you want to throw it out? Start new? Brilliant! Every software shop is the same If you look at the world of practicing doctors, they seem to fall (roughly) into two categories: those working in hospitals on patients that need somewhat urgent care (or are doing elective surgery), and doctors with private practices. Both seem to follow a similar structure, so that if you went from one personal care doctor to another, their structure would be about the same (waiting room, receptionist, files, someone to check your insurance, collect your copay). If you go get your car repaired at a mechanic, you expect a similar experience. If you go to a grocery store, you expect a similar experience. People in the software industry have nothing close to this. Each company may have widely varying setups. There are companies with just one programmer that does everything. Could you run a grocery store with just one person? (Well, maybe if it‚Äôs a tiny one person operation selling very few items). Or a doctor‚Äôs office (probably not because of insurances, unless you‚Äôre some kind of boutique doctor that makes home visits, and even then, I suspect you‚Äôre hire someone to do the billing, etc). The big companies can afford to have their own internal support structure that makes it easier for their average developer to deploy code. That support structure is often an internal thing, not an off-the-shelf, any small company can do it. If you were a car mechanic and wanted to open your own small shop, you‚Äôd probably know exactly what you need (at least, the very basics). These things probably have been (roughly) the same for decades, and even the new things, people probably generally agree on what is needed. But if you‚Äôre a small software shop‚Ä¶there‚Äôs no such standards. Do you want to use Atlassian tools? Or do you use a spreadsheet, or emails? Do you use some kind of company email? Or do you use personal email? There are lots of decisions, and it‚Äôs hardly standardized in the industry. You may think, say, version control is important. I guarantee there‚Äôs some software out there (maybe rare), that doesn‚Äôt use standard version control, and it probably does something important. And the people maintaining it may not even understand what version control is and why you need it. I‚Äôm serious. It‚Äôs like going to a surgeon with a bottle of whiskey and a bowl of leeches and they say ‚ÄúWhat‚Äôs anaesthetic?‚Äù We‚Äôll rewrite everything! ‚ÄúI know engineers, they love to change things‚ÄìDr. McCoy, Star Trek: The Motion Picture‚Äù Back in the 1990s, the skill most programmers needed? The ability to read other people‚Äôs programs. Most early programmers could write code, but they really had a hard time reading code, so they were almost always complaining that you needed a complete code rewrite to write that code in a way they could understand, without realizing the irony that the next programmer would want to throw away their code, and write it from scratch. Joel Spolsky, who used to blog many years ago (Joel on Software), used to say rewrites were basically evil. A functioning codebase should have been tested many times and many bugs have been removed. A new codebase will introduce new bugs and will be buggy. Software engineers aren‚Äôt that good about creating bug-free code (after all, what is a bug? are there specs?). He said it‚Äôs better to refactor to improve the code than to rewrite, but most developers like the feeling of an albatross of code off their neck that they don‚Äôt care about bugs they introducing. New code is wonderful! But realistically, you need to know what you‚Äôre building, and knowledge of the ins and outs of a programming language doesn‚Äôt help you figure out what it is you‚Äôre building. And sometimes your experts also want to control the kind of software you‚Äôre writing (mostly from a usability standpoint). I only have to understand a programming language Many self-taught programmers think ‚Äúit‚Äôs all about learning a programming language‚Äù. Some complain: why do I need to know HTML? Why do I need to know CSS? Why do I need to know SQL? Why do I need to know version control? Why do I need to know Github? Why do I need to know math? Why do I need to know business? Why do I need a deploy system? Why can‚Äôt someone else test my code? Why do I need a bug tracking/task tracking software? Why do I need to read my emails? Why do I need to update my tickets? It‚Äôs hard enough for most of you to learn a programming language. But it‚Äôs often the tip of the iceberg. To support web programming, many programming languages have a web framework, and sometimes those web frameworks do a lot of magic, to ‚Äúhelp you out‚Äù, and now, you thought you understood how a programming language works, but you don‚Äôt. (We used annotations, you‚Äôll love how it‚Äôs not crufty like the rest of Java!) Conclusions You don‚Äôt program hours a day unless it‚Äôs brand new software, and even then. You‚Äôll probably spend as much time in meetings (if you get to be important enough) than programming. There are generally two kinds of developers that survive in a company/organization that‚Äôs been around a while: those with strong technical skills, and those that have been around long enough to understand how things work (business-wise) even if they lack the technical chops. Sometimes (rarely), they are the same person. You don‚Äôt need to know computer science that well to write software that basically works, esp. if you know the business well. A lot of software may require only basic math skills and some understanding of how the web works. It‚Äôs sort of the equivalent of a doctor that learned how to doctor online, and only learned 10% of what they should. They may still be able to heal most basic things, but not be able to do some other basic stuff. We don‚Äôt trust that in doctors, but in software, it might be OK. Knowing the business is often at least as knowing the software, possibly more important. Your customers likely don‚Äôt want you to make ‚Äúimprovements‚Äù to their software, esp. those that you didn‚Äôt bother to consult them with. Most people tend to do maintenance programming, not green field (brand new) coding. You often have to teach yourself newer technologies. Your senior developers aren‚Äôt usually willing to be teachers and teach you from scratch. Communication skills are useful, but most developers became developers because they prefer to work alone. This doesn‚Äôt always lead to good software, no matter how skilled the person is. You shouldn‚Äôt think you‚Äôre writing code for yourself, but for the next person that has to maintain it. Don‚Äôt be too clever. Someone else will have to deal with your code (and it could be you, two years later). Maybe write some comments or something. Software can be developed in all sorts of ways, many not approaching ‚Äúbest practices‚Äù (which seems to change all the time). Not everyone is on the cutting edge (see New Jersey Cobol programs for filing unemployment). Being on that edge requires chasing a moving target that most companies think is a waste of time (why does Spring keep coming out with new versions‚Äìhaven‚Äôt they figured it out by now?). This means that there is no typical way software is developed. Yes, many companies share similarities (they have a Wiki, they use Jira, they use Bitbucket, they have a deploy system, they do code reviews), but it‚Äôs not universal. Your code is often not reviewed as much as it should, and you might get defensive about the comments you get. Code consistency helps (if you can tell who wrote the code based on stylistic choices, that may not always be the best thing). Credit: https://www.reddit.com/r/learnprogramming/comments/gtcwn4/the_misconceptions_of_a_programmers_life/" />
<meta property="og:description" content="I see frequent posts from beginning programmers wondering what programming is like, and I think it‚Äôs useful to address those issues. You program 8 hours a day at work This is probably the least true of all the things. Most programming jobs are maintenance jobs. The programs have all mostly been written years ago, and you are doing support, minor enhancements, bug fixes. Even if you get to do more than that, you are still not likely coding a large part of your day. It‚Äôs about meetings to decide what to do. Also, from my experience, unless you have some reason to dig deep into code (esp. if the code base is large), most people don‚Äôt bother. Our codebase is old and rickety. There aren‚Äôt comments. The business process isn‚Äôt exactly documented. I don‚Äôt want to wade through 2000 lines of Java code (per Java file) and try to understand the business behind it. Unless you‚Äôre working in a brand new project that needs a lot of code written (which I‚Äôve been in), you are probably not doing a lot of programming. A program is about programming I work at a university. Students, esp. computer science students, complain about our old system that runs a ‚Äúbatch style‚Äù programming system. That is, the system shuts down overnight, does a bunch of data processing, and opens again in the morning. They wonder why the system can‚Äôt be Facebook or Google or YouTube, and be up 24 hours a day. First, I think many such people would be surprised how many people (or really, how few people) are supporting these systems. You‚Äôd think there‚Äôs a team of 20 developers doing the best they can to keep this stuff running, and it‚Äôs like a well-oiled machine, but sometimes it‚Äôs less than half a dozen people, and we barely know the software‚Äôs purpose, but can do minor fixes and keep stuff running. Most software out there isn‚Äôt, as they say, rocket science. Sure, a few exceptions (say, SpaceX software). Most of the software encodes business practices, and most business practices are a weird arcane set of rules that have no basis in math or science, but is just how some company works. You write that in code, no matter how illogical it is. And often, the code, and a few old timers‚Äô memories are what holds the project together. Comments? Hah! A written business process? Hah! Programmers had one purpose: get the program to work. They didn‚Äôt think about who would maintain the code after they retired. The only saving grace was their background wasn‚Äôt so sophisticated as to create true spaghetti code (let‚Äôs use regular expressions and finite state machines and design patterns up the wazoo!). It‚Äôs often not the coding language (like Cobol) that prevents modernization (although it‚Äôs partly that), it‚Äôs that the business process was never formalized, and there are 100,000 lines of code no one wants to read (and only represents an approximation of what the people who wanted the code wanted‚Äîand they‚Äôre retired too!). I often point out the scene in the third Matrix movie where the councilman is talking to Neo about how these machines support their underground city, yet no one quite knows who built it or how it works. That‚Äôs a lot of software out there. Writing from scratch is not such a common experience (at least, from my perspective), and even when you do, it‚Äôs not always as organized as it could be. We may call it software engineering, but most engineering involves others looking at your work, and having input into fix it. Code reviews aren‚Äôt the same thing as people inspecting a building and seeing it every day. We often don‚Äôt rewrite things because the rewrite would be huge, would require a bunch of new developers, and doesn‚Äôt even have the support of the people we‚Äôre writing it for. As a programmer, since I wrote the code, my opinion is the most important OK, so you may know programming, but do you know the business you‚Äôre working in? Many a programmer or startup guy thinks ‚ÄúYou guys do something dumb, and I‚Äôm smart, so I can easily create a system that‚Äôs 10 times better than the crap you use. And you know what? I‚Äôm not even going to consult you about how the system should work. I‚Äôll make up my own. You are such idiots!‚Äù. Well, that may be, but they‚Äôre used to the system they are used to, and they‚Äôve thought about their own (arcane) business process for a long time, and if you build something that is completely different from what they are used to, they won‚Äôt say ‚Äúoh, we lack the intellect to understand your truly great software‚Äù, they‚Äôll just not use your software. If your user base is a bit older, and possibly, even if they aren‚Äôt, they will be used to doing things in a certain way. Maybe you can convince them that way isn‚Äôt smart, but if they questioned your lack of comments, your lack of coding structure, how what you wrote seems like gibberish, you might get defensive as well. The point is that you‚Äôre often writing software or maintaining software by those who use the software every day. As a programmer, you might even have the luxury to walk away after you write a code, never having used the code as your users use them, and they may ultimately hire someone new who maybe pays attention to what they actually want, even if you think it makes no sense. The program matters Many of you are learning to program. You think companies are willing to throw out a million line codebase because it‚Äôs written in an obsolete language. Who‚Äôs going to write it? You? (You, Mr. Wineburg?) A million lines of code is something that could take a lifetime to rewrite. Do you plan to read the code to understand what it does? Could you even do that? In any case, sometimes people think the program is king (or queen, or some elected position). It‚Äôs not. It‚Äôs the data. Say you‚Äôve run this legacy program for more than a decade. It fills up tables and table of data. You, being a person who hates legacy code, wants new DB tables, and new ways of storing information. Here‚Äôs the problem. What do you do with all that old data? Oh, you want to throw it out? Start new? Brilliant! Every software shop is the same If you look at the world of practicing doctors, they seem to fall (roughly) into two categories: those working in hospitals on patients that need somewhat urgent care (or are doing elective surgery), and doctors with private practices. Both seem to follow a similar structure, so that if you went from one personal care doctor to another, their structure would be about the same (waiting room, receptionist, files, someone to check your insurance, collect your copay). If you go get your car repaired at a mechanic, you expect a similar experience. If you go to a grocery store, you expect a similar experience. People in the software industry have nothing close to this. Each company may have widely varying setups. There are companies with just one programmer that does everything. Could you run a grocery store with just one person? (Well, maybe if it‚Äôs a tiny one person operation selling very few items). Or a doctor‚Äôs office (probably not because of insurances, unless you‚Äôre some kind of boutique doctor that makes home visits, and even then, I suspect you‚Äôre hire someone to do the billing, etc). The big companies can afford to have their own internal support structure that makes it easier for their average developer to deploy code. That support structure is often an internal thing, not an off-the-shelf, any small company can do it. If you were a car mechanic and wanted to open your own small shop, you‚Äôd probably know exactly what you need (at least, the very basics). These things probably have been (roughly) the same for decades, and even the new things, people probably generally agree on what is needed. But if you‚Äôre a small software shop‚Ä¶there‚Äôs no such standards. Do you want to use Atlassian tools? Or do you use a spreadsheet, or emails? Do you use some kind of company email? Or do you use personal email? There are lots of decisions, and it‚Äôs hardly standardized in the industry. You may think, say, version control is important. I guarantee there‚Äôs some software out there (maybe rare), that doesn‚Äôt use standard version control, and it probably does something important. And the people maintaining it may not even understand what version control is and why you need it. I‚Äôm serious. It‚Äôs like going to a surgeon with a bottle of whiskey and a bowl of leeches and they say ‚ÄúWhat‚Äôs anaesthetic?‚Äù We‚Äôll rewrite everything! ‚ÄúI know engineers, they love to change things‚ÄìDr. McCoy, Star Trek: The Motion Picture‚Äù Back in the 1990s, the skill most programmers needed? The ability to read other people‚Äôs programs. Most early programmers could write code, but they really had a hard time reading code, so they were almost always complaining that you needed a complete code rewrite to write that code in a way they could understand, without realizing the irony that the next programmer would want to throw away their code, and write it from scratch. Joel Spolsky, who used to blog many years ago (Joel on Software), used to say rewrites were basically evil. A functioning codebase should have been tested many times and many bugs have been removed. A new codebase will introduce new bugs and will be buggy. Software engineers aren‚Äôt that good about creating bug-free code (after all, what is a bug? are there specs?). He said it‚Äôs better to refactor to improve the code than to rewrite, but most developers like the feeling of an albatross of code off their neck that they don‚Äôt care about bugs they introducing. New code is wonderful! But realistically, you need to know what you‚Äôre building, and knowledge of the ins and outs of a programming language doesn‚Äôt help you figure out what it is you‚Äôre building. And sometimes your experts also want to control the kind of software you‚Äôre writing (mostly from a usability standpoint). I only have to understand a programming language Many self-taught programmers think ‚Äúit‚Äôs all about learning a programming language‚Äù. Some complain: why do I need to know HTML? Why do I need to know CSS? Why do I need to know SQL? Why do I need to know version control? Why do I need to know Github? Why do I need to know math? Why do I need to know business? Why do I need a deploy system? Why can‚Äôt someone else test my code? Why do I need a bug tracking/task tracking software? Why do I need to read my emails? Why do I need to update my tickets? It‚Äôs hard enough for most of you to learn a programming language. But it‚Äôs often the tip of the iceberg. To support web programming, many programming languages have a web framework, and sometimes those web frameworks do a lot of magic, to ‚Äúhelp you out‚Äù, and now, you thought you understood how a programming language works, but you don‚Äôt. (We used annotations, you‚Äôll love how it‚Äôs not crufty like the rest of Java!) Conclusions You don‚Äôt program hours a day unless it‚Äôs brand new software, and even then. You‚Äôll probably spend as much time in meetings (if you get to be important enough) than programming. There are generally two kinds of developers that survive in a company/organization that‚Äôs been around a while: those with strong technical skills, and those that have been around long enough to understand how things work (business-wise) even if they lack the technical chops. Sometimes (rarely), they are the same person. You don‚Äôt need to know computer science that well to write software that basically works, esp. if you know the business well. A lot of software may require only basic math skills and some understanding of how the web works. It‚Äôs sort of the equivalent of a doctor that learned how to doctor online, and only learned 10% of what they should. They may still be able to heal most basic things, but not be able to do some other basic stuff. We don‚Äôt trust that in doctors, but in software, it might be OK. Knowing the business is often at least as knowing the software, possibly more important. Your customers likely don‚Äôt want you to make ‚Äúimprovements‚Äù to their software, esp. those that you didn‚Äôt bother to consult them with. Most people tend to do maintenance programming, not green field (brand new) coding. You often have to teach yourself newer technologies. Your senior developers aren‚Äôt usually willing to be teachers and teach you from scratch. Communication skills are useful, but most developers became developers because they prefer to work alone. This doesn‚Äôt always lead to good software, no matter how skilled the person is. You shouldn‚Äôt think you‚Äôre writing code for yourself, but for the next person that has to maintain it. Don‚Äôt be too clever. Someone else will have to deal with your code (and it could be you, two years later). Maybe write some comments or something. Software can be developed in all sorts of ways, many not approaching ‚Äúbest practices‚Äù (which seems to change all the time). Not everyone is on the cutting edge (see New Jersey Cobol programs for filing unemployment). Being on that edge requires chasing a moving target that most companies think is a waste of time (why does Spring keep coming out with new versions‚Äìhaven‚Äôt they figured it out by now?). This means that there is no typical way software is developed. Yes, many companies share similarities (they have a Wiki, they use Jira, they use Bitbucket, they have a deploy system, they do code reviews), but it‚Äôs not universal. Your code is often not reviewed as much as it should, and you might get defensive about the comments you get. Code consistency helps (if you can tell who wrote the code based on stylistic choices, that may not always be the best thing). Credit: https://www.reddit.com/r/learnprogramming/comments/gtcwn4/the_misconceptions_of_a_programmers_life/" />
<link rel="canonical" href="/technology/software/programming/2020/05/30/the-misconceptions-of-a-programmer-s-life.html" />
<meta property="og:url" content="/technology/software/programming/2020/05/30/the-misconceptions-of-a-programmer-s-life.html" />
<meta property="og:site_name" content="Karthikeyan A K‚Äôs blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-30T20:58:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The Misconceptions of a Programmer‚Äôs Life" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-05-30T20:58:00+05:30","datePublished":"2020-05-30T20:58:00+05:30","description":"I see frequent posts from beginning programmers wondering what programming is like, and I think it‚Äôs useful to address those issues. You program 8 hours a day at work This is probably the least true of all the things. Most programming jobs are maintenance jobs. The programs have all mostly been written years ago, and you are doing support, minor enhancements, bug fixes. Even if you get to do more than that, you are still not likely coding a large part of your day. It‚Äôs about meetings to decide what to do. Also, from my experience, unless you have some reason to dig deep into code (esp. if the code base is large), most people don‚Äôt bother. Our codebase is old and rickety. There aren‚Äôt comments. The business process isn‚Äôt exactly documented. I don‚Äôt want to wade through 2000 lines of Java code (per Java file) and try to understand the business behind it. Unless you‚Äôre working in a brand new project that needs a lot of code written (which I‚Äôve been in), you are probably not doing a lot of programming. A program is about programming I work at a university. Students, esp. computer science students, complain about our old system that runs a ‚Äúbatch style‚Äù programming system. That is, the system shuts down overnight, does a bunch of data processing, and opens again in the morning. They wonder why the system can‚Äôt be Facebook or Google or YouTube, and be up 24 hours a day. First, I think many such people would be surprised how many people (or really, how few people) are supporting these systems. You‚Äôd think there‚Äôs a team of 20 developers doing the best they can to keep this stuff running, and it‚Äôs like a well-oiled machine, but sometimes it‚Äôs less than half a dozen people, and we barely know the software‚Äôs purpose, but can do minor fixes and keep stuff running. Most software out there isn‚Äôt, as they say, rocket science. Sure, a few exceptions (say, SpaceX software). Most of the software encodes business practices, and most business practices are a weird arcane set of rules that have no basis in math or science, but is just how some company works. You write that in code, no matter how illogical it is. And often, the code, and a few old timers‚Äô memories are what holds the project together. Comments? Hah! A written business process? Hah! Programmers had one purpose: get the program to work. They didn‚Äôt think about who would maintain the code after they retired. The only saving grace was their background wasn‚Äôt so sophisticated as to create true spaghetti code (let‚Äôs use regular expressions and finite state machines and design patterns up the wazoo!). It‚Äôs often not the coding language (like Cobol) that prevents modernization (although it‚Äôs partly that), it‚Äôs that the business process was never formalized, and there are 100,000 lines of code no one wants to read (and only represents an approximation of what the people who wanted the code wanted‚Äîand they‚Äôre retired too!). I often point out the scene in the third Matrix movie where the councilman is talking to Neo about how these machines support their underground city, yet no one quite knows who built it or how it works. That‚Äôs a lot of software out there. Writing from scratch is not such a common experience (at least, from my perspective), and even when you do, it‚Äôs not always as organized as it could be. We may call it software engineering, but most engineering involves others looking at your work, and having input into fix it. Code reviews aren‚Äôt the same thing as people inspecting a building and seeing it every day. We often don‚Äôt rewrite things because the rewrite would be huge, would require a bunch of new developers, and doesn‚Äôt even have the support of the people we‚Äôre writing it for. As a programmer, since I wrote the code, my opinion is the most important OK, so you may know programming, but do you know the business you‚Äôre working in? Many a programmer or startup guy thinks ‚ÄúYou guys do something dumb, and I‚Äôm smart, so I can easily create a system that‚Äôs 10 times better than the crap you use. And you know what? I‚Äôm not even going to consult you about how the system should work. I‚Äôll make up my own. You are such idiots!‚Äù. Well, that may be, but they‚Äôre used to the system they are used to, and they‚Äôve thought about their own (arcane) business process for a long time, and if you build something that is completely different from what they are used to, they won‚Äôt say ‚Äúoh, we lack the intellect to understand your truly great software‚Äù, they‚Äôll just not use your software. If your user base is a bit older, and possibly, even if they aren‚Äôt, they will be used to doing things in a certain way. Maybe you can convince them that way isn‚Äôt smart, but if they questioned your lack of comments, your lack of coding structure, how what you wrote seems like gibberish, you might get defensive as well. The point is that you‚Äôre often writing software or maintaining software by those who use the software every day. As a programmer, you might even have the luxury to walk away after you write a code, never having used the code as your users use them, and they may ultimately hire someone new who maybe pays attention to what they actually want, even if you think it makes no sense. The program matters Many of you are learning to program. You think companies are willing to throw out a million line codebase because it‚Äôs written in an obsolete language. Who‚Äôs going to write it? You? (You, Mr. Wineburg?) A million lines of code is something that could take a lifetime to rewrite. Do you plan to read the code to understand what it does? Could you even do that? In any case, sometimes people think the program is king (or queen, or some elected position). It‚Äôs not. It‚Äôs the data. Say you‚Äôve run this legacy program for more than a decade. It fills up tables and table of data. You, being a person who hates legacy code, wants new DB tables, and new ways of storing information. Here‚Äôs the problem. What do you do with all that old data? Oh, you want to throw it out? Start new? Brilliant! Every software shop is the same If you look at the world of practicing doctors, they seem to fall (roughly) into two categories: those working in hospitals on patients that need somewhat urgent care (or are doing elective surgery), and doctors with private practices. Both seem to follow a similar structure, so that if you went from one personal care doctor to another, their structure would be about the same (waiting room, receptionist, files, someone to check your insurance, collect your copay). If you go get your car repaired at a mechanic, you expect a similar experience. If you go to a grocery store, you expect a similar experience. People in the software industry have nothing close to this. Each company may have widely varying setups. There are companies with just one programmer that does everything. Could you run a grocery store with just one person? (Well, maybe if it‚Äôs a tiny one person operation selling very few items). Or a doctor‚Äôs office (probably not because of insurances, unless you‚Äôre some kind of boutique doctor that makes home visits, and even then, I suspect you‚Äôre hire someone to do the billing, etc). The big companies can afford to have their own internal support structure that makes it easier for their average developer to deploy code. That support structure is often an internal thing, not an off-the-shelf, any small company can do it. If you were a car mechanic and wanted to open your own small shop, you‚Äôd probably know exactly what you need (at least, the very basics). These things probably have been (roughly) the same for decades, and even the new things, people probably generally agree on what is needed. But if you‚Äôre a small software shop‚Ä¶there‚Äôs no such standards. Do you want to use Atlassian tools? Or do you use a spreadsheet, or emails? Do you use some kind of company email? Or do you use personal email? There are lots of decisions, and it‚Äôs hardly standardized in the industry. You may think, say, version control is important. I guarantee there‚Äôs some software out there (maybe rare), that doesn‚Äôt use standard version control, and it probably does something important. And the people maintaining it may not even understand what version control is and why you need it. I‚Äôm serious. It‚Äôs like going to a surgeon with a bottle of whiskey and a bowl of leeches and they say ‚ÄúWhat‚Äôs anaesthetic?‚Äù We‚Äôll rewrite everything! ‚ÄúI know engineers, they love to change things‚ÄìDr. McCoy, Star Trek: The Motion Picture‚Äù Back in the 1990s, the skill most programmers needed? The ability to read other people‚Äôs programs. Most early programmers could write code, but they really had a hard time reading code, so they were almost always complaining that you needed a complete code rewrite to write that code in a way they could understand, without realizing the irony that the next programmer would want to throw away their code, and write it from scratch. Joel Spolsky, who used to blog many years ago (Joel on Software), used to say rewrites were basically evil. A functioning codebase should have been tested many times and many bugs have been removed. A new codebase will introduce new bugs and will be buggy. Software engineers aren‚Äôt that good about creating bug-free code (after all, what is a bug? are there specs?). He said it‚Äôs better to refactor to improve the code than to rewrite, but most developers like the feeling of an albatross of code off their neck that they don‚Äôt care about bugs they introducing. New code is wonderful! But realistically, you need to know what you‚Äôre building, and knowledge of the ins and outs of a programming language doesn‚Äôt help you figure out what it is you‚Äôre building. And sometimes your experts also want to control the kind of software you‚Äôre writing (mostly from a usability standpoint). I only have to understand a programming language Many self-taught programmers think ‚Äúit‚Äôs all about learning a programming language‚Äù. Some complain: why do I need to know HTML? Why do I need to know CSS? Why do I need to know SQL? Why do I need to know version control? Why do I need to know Github? Why do I need to know math? Why do I need to know business? Why do I need a deploy system? Why can‚Äôt someone else test my code? Why do I need a bug tracking/task tracking software? Why do I need to read my emails? Why do I need to update my tickets? It‚Äôs hard enough for most of you to learn a programming language. But it‚Äôs often the tip of the iceberg. To support web programming, many programming languages have a web framework, and sometimes those web frameworks do a lot of magic, to ‚Äúhelp you out‚Äù, and now, you thought you understood how a programming language works, but you don‚Äôt. (We used annotations, you‚Äôll love how it‚Äôs not crufty like the rest of Java!) Conclusions You don‚Äôt program hours a day unless it‚Äôs brand new software, and even then. You‚Äôll probably spend as much time in meetings (if you get to be important enough) than programming. There are generally two kinds of developers that survive in a company/organization that‚Äôs been around a while: those with strong technical skills, and those that have been around long enough to understand how things work (business-wise) even if they lack the technical chops. Sometimes (rarely), they are the same person. You don‚Äôt need to know computer science that well to write software that basically works, esp. if you know the business well. A lot of software may require only basic math skills and some understanding of how the web works. It‚Äôs sort of the equivalent of a doctor that learned how to doctor online, and only learned 10% of what they should. They may still be able to heal most basic things, but not be able to do some other basic stuff. We don‚Äôt trust that in doctors, but in software, it might be OK. Knowing the business is often at least as knowing the software, possibly more important. Your customers likely don‚Äôt want you to make ‚Äúimprovements‚Äù to their software, esp. those that you didn‚Äôt bother to consult them with. Most people tend to do maintenance programming, not green field (brand new) coding. You often have to teach yourself newer technologies. Your senior developers aren‚Äôt usually willing to be teachers and teach you from scratch. Communication skills are useful, but most developers became developers because they prefer to work alone. This doesn‚Äôt always lead to good software, no matter how skilled the person is. You shouldn‚Äôt think you‚Äôre writing code for yourself, but for the next person that has to maintain it. Don‚Äôt be too clever. Someone else will have to deal with your code (and it could be you, two years later). Maybe write some comments or something. Software can be developed in all sorts of ways, many not approaching ‚Äúbest practices‚Äù (which seems to change all the time). Not everyone is on the cutting edge (see New Jersey Cobol programs for filing unemployment). Being on that edge requires chasing a moving target that most companies think is a waste of time (why does Spring keep coming out with new versions‚Äìhaven‚Äôt they figured it out by now?). This means that there is no typical way software is developed. Yes, many companies share similarities (they have a Wiki, they use Jira, they use Bitbucket, they have a deploy system, they do code reviews), but it‚Äôs not universal. Your code is often not reviewed as much as it should, and you might get defensive about the comments you get. Code consistency helps (if you can tell who wrote the code based on stylistic choices, that may not always be the best thing). Credit: https://www.reddit.com/r/learnprogramming/comments/gtcwn4/the_misconceptions_of_a_programmers_life/","headline":"The Misconceptions of a Programmer‚Äôs Life","mainEntityOfPage":{"@type":"WebPage","@id":"/technology/software/programming/2020/05/30/the-misconceptions-of-a-programmer-s-life.html"},"url":"/technology/software/programming/2020/05/30/the-misconceptions-of-a-programmer-s-life.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Karthikeyan A K's blog" /><script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
  </script>

<style media="screen">
  /* responsive videos */
  .video figure {
    position: relative;
    padding-bottom: 56.25%;
    height: 0;
    overflow: hidden;
  }

  .video iframe, .video object, .video embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .pagination{
    margin-top: 40px;
  }

  a.paginate {
    background-color: #4CAF50;
    color: white;
    padding: 8px 16px;
  }


  .darkmode--activated .site-title, .darkmode--activated .page-link{
    color: white;
  }

  @media only screen and (min-width: 600px){
    .darkmode--activated .page-link {
      color: white;
    }
  }

  @media only screen and (max-width: 600px){
    .darkmode--activated .page-link{
      color: black;
    }
  }

  .darkmode--activated video {
    filter: invert(0%);
  }

  .darkmode--activated .twitter-tweet{
    filter: invert(0%);
  }

  .darkmode--activated .MJXc-display{
    color: white !important;
  }

  .darkmode--activated .MathJax_CHTML{
    color: white !important;
  }

  
</style>

  <link rel="icon" type="image/x-icon" href="https://ia600308.us.archive.org/3/items/ak-logo-3/AK%20Logo%203.svg">
  <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
  <script>
    function addDarkmodeWidget() {
      const options = {
        label: 'üåì'
      }

      new Darkmode(options).showWidget();
    }
    window.addEventListener('load', addDarkmodeWidget);
  </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Karthikeyan A K&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">Karthikeyan A K</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/search.html">Search</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The Misconceptions of a Programmer&#39;s Life</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-05-30T20:58:00+05:30" itemprop="datePublished">May 30, 2020
      </time></p>
  </header>

  <div class="post-categories">
    
    
      <a href="/categories/#technology">technology</a>
      &nbsp;
    
      <a href="/categories/#software">software</a>
      &nbsp;
    
      <a href="/categories/#programming">programming</a>
      
    
  </div>
  <p></p>
  <div class="post-content">
    <p>I see frequent posts from beginning programmers wondering what programming is like, and I think it‚Äôs useful to address those issues.</p>

<p><strong>You program 8 hours a day at work</strong></p>

<p>This is probably the least true of all the things. Most programming jobs are maintenance jobs. The programs have all mostly been written years ago, and you are doing support, minor enhancements, bug fixes. Even if you get to do more than that, you are still not likely coding a large part of your day. It‚Äôs about meetings to decide what to do.</p>

<p>Also, from my experience, unless you have some reason to dig deep into code (esp. if the code base is large), most people don‚Äôt bother. Our codebase is old and rickety. There aren‚Äôt comments. The business process isn‚Äôt exactly documented. I don‚Äôt want to wade through 2000 lines of Java code (per Java file) and try to understand the business behind it.</p>

<p>Unless you‚Äôre working in a brand new project that needs a lot of code written (which I‚Äôve been in), you are probably not doing a lot of programming.</p>

<p><strong>A program is about programming</strong></p>

<p>I work at a university. Students, esp. computer science students, complain about our old system that runs a ‚Äúbatch style‚Äù programming system. That is, the system shuts down overnight, does a bunch of data processing, and opens again in the morning. They wonder why the system can‚Äôt be Facebook or Google or YouTube, and be up 24 hours a day.</p>

<p>First, I think many such people would be surprised how many people (or really, how few people) are supporting these systems. You‚Äôd think there‚Äôs a team of 20 developers doing the best they can to keep this stuff running, and it‚Äôs like a well-oiled machine, but sometimes it‚Äôs less than half a dozen people, and we barely know the software‚Äôs purpose, but can do minor fixes and keep stuff running.</p>

<p>Most software out there isn‚Äôt, as they say, rocket science. Sure, a few exceptions (say, SpaceX software). Most of the software encodes business practices, and most business practices are a weird arcane set of rules that have no basis in math or science, but is just how some company works. You write that in code, no matter how illogical it is. And often, the code, and a few old timers‚Äô memories are what holds the project together.</p>

<p>Comments? Hah! A written business process? Hah! Programmers had one purpose: get the program to work. They didn‚Äôt think about who would maintain the code after they retired. The only saving grace was their background wasn‚Äôt so sophisticated as to create true spaghetti code (let‚Äôs use regular expressions and finite state machines and design patterns up the wazoo!).</p>

<p>It‚Äôs often not the coding language (like Cobol) that prevents modernization (although it‚Äôs partly that), it‚Äôs that the business process was never formalized, and there are 100,000 lines of code no one wants to read (and only represents an <em>approximation</em> of what the people who wanted the code wanted‚Äîand they‚Äôre retired too!).</p>

<p>I often point out the scene in the third Matrix movie where the councilman is talking to Neo about how these machines support their underground city, yet no one quite knows who built it or how it works. That‚Äôs a lot of software out there.</p>

<p>Writing from scratch is not such a common experience (at least, from my perspective), and even when you do, it‚Äôs not always as organized as it could be. We may call it software engineering, but most engineering involves others looking at your work, and having input into fix it. Code reviews aren‚Äôt the same thing as people inspecting a building and seeing it every day.</p>

<p>We often don‚Äôt rewrite things because the rewrite would be huge, would require a bunch of new developers, and doesn‚Äôt even have the support of the people we‚Äôre writing it for.</p>

<p><strong>As a programmer, since I wrote the code, my opinion is the most important</strong></p>

<p>OK, so you may <em>know</em> programming, but do you know the business you‚Äôre working in? Many a programmer or startup guy thinks ‚ÄúYou guys do something dumb, and I‚Äôm smart, so I can easily create a system that‚Äôs 10 times better than the crap you use. And you know what? I‚Äôm not even going to consult you about how the system <em>should</em> work. I‚Äôll make up my own. You are such <em>idiots</em>!‚Äù.</p>

<p>Well, that may be, but they‚Äôre used to the system they are used to, and they‚Äôve thought about their own (arcane) business process for a long time, and if you build something that is completely different from what they are used to, they won‚Äôt say ‚Äúoh, we lack the intellect to understand your truly great software‚Äù, they‚Äôll just not use your software.</p>

<p>If your user base is a bit older, and possibly, even if they aren‚Äôt, they will be used to doing things in a certain way. Maybe you can convince them that way isn‚Äôt smart, but if they questioned your lack of comments, your lack of coding structure, how what you wrote seems like gibberish, you might get defensive as well.</p>

<p>The point is that you‚Äôre often writing software or maintaining software by those who use the software every day. As a programmer, you might even have the luxury to walk away after you write a code, never having used the code as your users use them, and they may ultimately hire someone new who maybe pays attention to what they actually want, even if you think it makes no sense.</p>

<p><strong>The program matters</strong></p>

<p>Many of you are learning to program. You think companies are willing to throw out a million line codebase because it‚Äôs <em>written in an obsolete language</em>. Who‚Äôs going to write it? You? (You, Mr. Wineburg?)</p>

<p>A million lines of code is something that could take a lifetime to rewrite. Do you plan to read the code to understand what it does? Could you even do that?</p>

<p>In any case, sometimes people think the program is king (or queen, or some elected position). It‚Äôs not.</p>

<p>It‚Äôs the data.</p>

<p>Say you‚Äôve run this legacy program for more than a decade. It fills up tables and table of data. You, being a person who hates legacy code, wants new DB tables, and new ways of storing information.</p>

<p>Here‚Äôs the problem. What do you do with all that old data? Oh, you want to throw it out? Start new? <em>Brilliant!</em></p>

<p><strong>Every software shop is the same</strong></p>

<p>If you look at the world of practicing doctors, they seem to fall (roughly) into two categories: those working in hospitals on patients that need somewhat urgent care (or are doing elective surgery), and doctors with private practices.</p>

<p>Both seem to follow a similar structure, so that if you went from one personal care doctor to another, their structure would be about the same (waiting room, receptionist, files, someone to check your insurance, collect your copay). If you go get your car repaired at a mechanic, you expect a similar experience. If you go to a grocery store, you expect a similar experience.</p>

<p>People in the software industry have nothing close to this. Each company may have widely varying setups. There are companies with just one programmer that does everything. Could you run a grocery store with just one person? (Well, maybe if it‚Äôs a tiny one person operation selling very few items). Or a doctor‚Äôs office (probably not because of insurances, unless you‚Äôre some kind of boutique doctor that makes home visits, and even then, I suspect you‚Äôre hire someone to do the billing, etc).</p>

<p>The big companies can afford to have their own internal support structure that makes it easier for their average developer to deploy code. That support structure is often an internal thing, not an off-the-shelf, any small company can do it. If you were a car mechanic and wanted to open your own small shop, you‚Äôd probably know exactly what you need (at least, the very basics). These things probably have been (roughly) the same for decades, and even the new things, people probably generally agree on what is needed.</p>

<p>But if you‚Äôre a small software shop‚Ä¶there‚Äôs no such standards. Do you want to use Atlassian tools? Or do you use a spreadsheet, or emails? Do you use some kind of company email? Or do you use personal email? There are lots of decisions, and it‚Äôs hardly standardized in the industry.</p>

<p>You may think, say, version control is important. I guarantee there‚Äôs some software out there (maybe rare), that doesn‚Äôt use standard version control, and it probably does something important. And the people maintaining it may not even understand what version control is and why you need it. I‚Äôm serious.</p>

<p>It‚Äôs like going to a surgeon with a bottle of whiskey and a bowl of leeches and they say ‚ÄúWhat‚Äôs anaesthetic?‚Äù</p>

<p><strong>We‚Äôll rewrite everything!</strong></p>

<p>‚ÄúI know engineers, they love to change things‚ÄìDr. McCoy, Star Trek: The Motion Picture‚Äù</p>

<p>Back in the 1990s, the skill most programmers needed? The ability to read other people‚Äôs programs. Most early programmers could write code, but they really had a hard time <em>reading</em> code, so they were almost always complaining that you needed a complete code rewrite to write that code in a way they could understand, without realizing the irony that the next programmer would want to throw away their code, and write it from scratch.</p>

<p>Joel Spolsky, who used to blog many years ago (Joel on Software), used to say rewrites were basically evil. A functioning codebase should have been tested many times and many bugs have been removed. A new codebase will introduce new bugs and will be buggy. Software engineers aren‚Äôt that good about creating bug-free code (after all, what is a bug? are there specs?). He said it‚Äôs better to refactor to improve the code than to rewrite, but most developers like the feeling of an albatross of code off their neck that they don‚Äôt care about bugs they introducing.</p>

<p><strong>New code is wonderful!</strong></p>

<p>But realistically, you need to know what you‚Äôre building, and knowledge of the ins and outs of a programming language doesn‚Äôt help you figure out what it is you‚Äôre building. And sometimes your experts also want to control the kind of software you‚Äôre writing (mostly from a usability standpoint).</p>

<p><strong>I only have to understand a programming language</strong></p>

<p>Many self-taught programmers think ‚Äúit‚Äôs all about learning a programming language‚Äù.</p>

<p>Some complain: why do I need to know HTML? Why do I need to know CSS? Why do I need to know SQL? Why do I need to know version control? Why do I need to know Github? Why do I need to know math? Why do I need to know business? Why do I need a deploy system? Why can‚Äôt someone else test my code? Why do I need a bug tracking/task tracking software? Why do I need to read my emails? Why do I need to update my tickets?</p>

<p>It‚Äôs hard enough for most of you to learn a programming language. But it‚Äôs often the tip of the iceberg. To support web programming, many programming languages have a web framework, and sometimes those web frameworks do a lot of magic, to ‚Äúhelp you out‚Äù, and now, you thought you understood how a programming language works, but you don‚Äôt. (We used <em>annotations</em>, you‚Äôll love how it‚Äôs not crufty like the rest of Java!)</p>

<p><strong>Conclusions</strong></p>

<ul>
  <li>
    <p>You don‚Äôt program hours a day unless it‚Äôs brand new software, and even then.</p>
  </li>
  <li>
    <p>You‚Äôll probably spend as much time in meetings (if you get to be important enough) than programming.</p>
  </li>
  <li>
    <p>There are generally two kinds of developers that survive in a company/organization that‚Äôs been around a while: those with strong technical skills, and those that have been around long enough to understand how things work (business-wise) even if they lack the technical chops. Sometimes (rarely), they are the same person.</p>
  </li>
  <li>
    <p>You don‚Äôt need to know computer science that well to write software that basically works, esp. if you know the business well. A lot of software may require only basic math skills and some understanding of how the web works. It‚Äôs sort of the equivalent of a doctor that learned how to doctor online, and only learned 10% of what they should. They may still be able to heal most basic things, but not be able to do some other basic stuff. We don‚Äôt trust that in doctors, but in software, it might be OK.</p>
  </li>
  <li>
    <p>Knowing the business is often at least as knowing the software, possibly more important.</p>
  </li>
  <li>
    <p>Your customers likely don‚Äôt want you to make ‚Äúimprovements‚Äù to their software, esp. those that you didn‚Äôt bother to consult them with.</p>
  </li>
  <li>
    <p>Most people tend to do maintenance programming, not green field (brand new) coding.</p>
  </li>
  <li>
    <p>You often have to teach yourself newer technologies. Your senior developers aren‚Äôt usually willing to be teachers and teach you from scratch.</p>
  </li>
  <li>
    <p>Communication skills are useful, but most developers became developers because they prefer to work alone. This doesn‚Äôt always lead to good software, no matter how skilled the person is.</p>
  </li>
  <li>
    <p>You shouldn‚Äôt think you‚Äôre writing code for yourself, but for the next person that has to maintain it. Don‚Äôt be too clever. Someone else will have to deal with your code (and it could be you, two years later). Maybe write some comments or something.</p>
  </li>
  <li>
    <p>Software can be developed in all sorts of ways, many not approaching ‚Äúbest practices‚Äù (which seems to change all the time). Not everyone is on the cutting edge (see New Jersey Cobol programs for filing unemployment). Being on that edge requires chasing a moving target that most companies think is a waste of time (why does Spring keep coming out with new versions‚Äìhaven‚Äôt they figured it out by now?). This means that there is no typical way software is developed. Yes, many companies share similarities (they have a Wiki, they use Jira, they use Bitbucket, they have a deploy system, they do code reviews), but it‚Äôs not universal.</p>
  </li>
  <li>
    <p>Your code is often not reviewed as much as it should, and you might get defensive about the comments you get.</p>
  </li>
  <li>
    <p>Code consistency helps (if you can tell who wrote the code based on stylistic choices, that may not always be the best thing).</p>
  </li>
</ul>

<p><strong>Credit:</strong> <a href="https://www.reddit.com/r/learnprogramming/comments/gtcwn4/the_misconceptions_of_a_programmers_life/">https://www.reddit.com/r/learnprogramming/comments/gtcwn4/the_misconceptions_of_a_programmers_life/</a></p>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Karthikeyan A K&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Karthikeyan A K&#39;s blog</li><li><a class="u-email" href="mailto:mindaslab@protonmail.com">mindaslab@protonmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello World, I am Karthikeyan. I eat briyani and worship Boomthata, the creator of God and Satan.
</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
